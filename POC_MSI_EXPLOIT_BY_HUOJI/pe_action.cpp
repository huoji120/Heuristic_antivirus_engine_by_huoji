#include "head.h"
#include "pe_action.h"
#include "virtual_helper.h"
/*
DWORD64 get_export_function(uint64_t params_dll_base,char* params_function_name) {
	//导出表
	DWORD uExportSize = 0;
	static RtlImageDirectoryEntryToDataFn RtlImageDirectoryEntryToData = NULL;
	if(RtlImageDirectoryEntryToData == NULL)
		RtlImageDirectoryEntryToData = (RtlImageDirectoryEntryToDataFn)GetProcAddress(LoadLibraryA("ntdll.dll"), "RtlImageDirectoryEntryToData");
	PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData((PVOID)params_dll_base, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &uExportSize);

	if (pImageExportDirectory)
	{
		moudle_export export_data = { 0 };
		DWORD dwNumberOfNames = (DWORD)(pImageExportDirectory->NumberOfNames);
		DWORD* pAddressOfFunction = (DWORD*)((PUCHAR)params_dll_base + pImageExportDirectory->AddressOfFunctions);
		DWORD* pAddressOfNames = (DWORD*)((PUCHAR)params_dll_base + pImageExportDirectory->AddressOfNames);
		WORD* pAddressOfNameOrdinals = (WORD*)((PUCHAR)params_dll_base + pImageExportDirectory->AddressOfNameOrdinals);

		for (size_t i = 0; i < dwNumberOfNames; i++)
		{
			char* strFunction = (char*)((PUCHAR)params_dll_base + pAddressOfNames[i]);
			if (strcmp(strFunction, params_function_name) == 0) {
				DWORD functionRva = pAddressOfFunction[pAddressOfNameOrdinals[i]];
				printf("%s functionRva: %08X \n", params_function_name, functionRva);
				DWORD result = (DWORD)params_dll_base + functionRva;
				return result;
			}
		}
	}
	return NULL;
}*/
//解决套娃问题
void pe_action::map_pe_import(DWORD64 params_moudle_base) {
	PIMAGE_DOS_HEADER dos_head = (PIMAGE_DOS_HEADER)params_moudle_base;
	PIMAGE_NT_HEADERS nt_head = (PIMAGE_NT_HEADERS)((LPBYTE)params_moudle_base + dos_head->e_lfanew);
	PIMAGE_IMPORT_DESCRIPTOR import_driectory = (PIMAGE_IMPORT_DESCRIPTOR)((LPBYTE)params_moudle_base + m_nt_head->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
	PIMAGE_IMPORT_DESCRIPTOR pIID = import_driectory;
	DWORD64 Function;
	
	while (pIID->Characteristics)
	{
		std::vector<moudle_import> import_data_dict;
		std::vector<moudle_export> export_data_dict;
		PIMAGE_THUNK_DATA OrigFirstThunk = (PIMAGE_THUNK_DATA)((LPBYTE)m_image_base + pIID->OriginalFirstThunk);
		PIMAGE_THUNK_DATA FirstThunk = (PIMAGE_THUNK_DATA)((LPBYTE)m_image_base + pIID->FirstThunk);
		LPCSTR dll_name = (LPCSTR)m_image_base + pIID->Name;
		HMODULE hModule = LoadLibraryA(dll_name);
		while (OrigFirstThunk->u1.AddressOfData)
		{
			//导入表
			LPCSTR function_name;
			if (OrigFirstThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG)
			{
				function_name = (LPCSTR)(OrigFirstThunk->u1.Ordinal & 0xFFFF);
				//Function = (DWORD64)get_export_function((uint64_t)hModule, (char*)function_name);
				Function = (DWORD64)GetProcAddress(hModule, function_name);
			}
			else
			{
				PIMAGE_IMPORT_BY_NAME pIBN = (PIMAGE_IMPORT_BY_NAME)((LPBYTE)m_image_base + OrigFirstThunk->u1.AddressOfData);
				function_name = (LPCSTR)pIBN->Name;
				//Function = (DWORD64)get_export_function((uint64_t)hModule, (char*)function_name);
				Function = (DWORD64)GetProcAddress(hModule, function_name);
			}
			printf("[PE] fixing import :%s %s %08X to %08X \n", dll_name, function_name, FirstThunk->u1.Function, Function);
			FirstThunk->u1.Function = Function;
			moudle_import import_data = { 0 };
			memcpy(import_data.name, (char*)function_name, strlen(function_name));
			import_data.function_address = Function;
			import_data_dict.push_back(import_data);
			OrigFirstThunk++;
			FirstThunk++;
		}
		/*
		//导出表
		DWORD uExportSize = 0;
		RtlImageDirectoryEntryToDataFn RtlImageDirectoryEntryToData = (RtlImageDirectoryEntryToDataFn)GetProcAddress(LoadLibraryA("ntdll.dll"), "RtlImageDirectoryEntryToData");
		PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(hModule, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &uExportSize);

		if (pImageExportDirectory)
		{
			moudle_export export_data = { 0 };
			DWORD dwNumberOfNames = (DWORD)(pImageExportDirectory->NumberOfNames);
			DWORD* pAddressOfFunction = (DWORD*)((PUCHAR)hModule + pImageExportDirectory->AddressOfFunctions);
			DWORD* pAddressOfNames = (DWORD*)((PUCHAR)hModule + pImageExportDirectory->AddressOfNames);
			WORD* pAddressOfNameOrdinals = (WORD*)((PUCHAR)hModule + pImageExportDirectory->AddressOfNameOrdinals);

			for (size_t i = 0; i < dwNumberOfNames; i++)
			{
				char* strFunction = (char*)((PUCHAR)hModule + pAddressOfNames[i]);

				DWORD functionRva = pAddressOfFunction[pAddressOfNameOrdinals[i]];
				DWORD base = (DWORD)hModule + functionRva;
				moudle_export export_data = { 0 };
				memcpy(export_data.name, (char*)strFunction, strlen(strFunction));
				export_data.function_address = base;
				export_data_dict.push_back(export_data);
			}
		}
		*/
		export_data_dict = get_export((PVOID)hModule);
		push_to_virtual_helper(export_data_dict, import_data_dict, (char*)dll_name, (uint64_t)hModule);
		pIID++;
	}

}
void pe_action::relocation(PVOID params_image_base, PIMAGE_NT_HEADERS params_nt_head) {
	PDWORD ptr = NULL;
	PWORD list = NULL;
	PIMAGE_SECTION_HEADER pISH = (PIMAGE_SECTION_HEADER)(params_nt_head + 1);
	for (int i = 0; i < params_nt_head->FileHeader.NumberOfSections; i++)
	{
		WriteProcessMemory((HANDLE)-1, (PVOID)((LPBYTE)params_image_base + pISH[i].VirtualAddress), (PVOID)((LPBYTE)m_buffer + pISH[i].PointerToRawData), pISH[i].SizeOfRawData, NULL);
	}

	//2. 重定位 
	DWORD64 m_delta = (DWORD64)((LPBYTE)params_image_base - params_nt_head->OptionalHeader.ImageBase);
	PIMAGE_BASE_RELOCATION m_baserelocation = (PIMAGE_BASE_RELOCATION)((LPBYTE)params_image_base + params_nt_head->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
	while (m_baserelocation->VirtualAddress)
	{
		if (m_baserelocation->SizeOfBlock >= sizeof(IMAGE_BASE_RELOCATION))
		{
			DWORD count = (m_baserelocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
			list = (PWORD)(m_baserelocation + 1);

			for (int i = 0; i < count; i++)
			{
				if (list[i])
				{
					ptr = (PDWORD)((LPBYTE)params_image_base + (m_baserelocation->VirtualAddress + (list[i] & 0xFFF)));
					*ptr += m_delta;
				}
			}
		}

		m_baserelocation = (PIMAGE_BASE_RELOCATION)((LPBYTE)m_baserelocation + m_baserelocation->SizeOfBlock);
	}
}
std::vector<moudle_export> pe_action::get_export(PVOID params_image_base) {
	std::vector<moudle_export> result;
	//导出表
	DWORD uExportSize = 0;
	RtlImageDirectoryEntryToDataFn RtlImageDirectoryEntryToData = (RtlImageDirectoryEntryToDataFn)GetProcAddress(LoadLibraryA("ntdll.dll"), "RtlImageDirectoryEntryToData");
	PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData((PVOID)params_image_base, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &uExportSize);

	if (pImageExportDirectory)
	{
		moudle_export export_data = { 0 };
		DWORD dwNumberOfNames = (DWORD)(pImageExportDirectory->NumberOfNames);
		DWORD* pAddressOfFunction = (DWORD*)((PUCHAR)params_image_base + pImageExportDirectory->AddressOfFunctions);
		DWORD* pAddressOfNames = (DWORD*)((PUCHAR)params_image_base + pImageExportDirectory->AddressOfNames);
		WORD* pAddressOfNameOrdinals = (WORD*)((PUCHAR)params_image_base + pImageExportDirectory->AddressOfNameOrdinals);

		for (size_t i = 0; i < dwNumberOfNames; i++)
		{
			char* strFunction = (char*)((PUCHAR)params_image_base + pAddressOfNames[i]);

			DWORD functionRva = pAddressOfFunction[pAddressOfNameOrdinals[i]];
			DWORD base = (DWORD)params_image_base + functionRva;
			moudle_export export_data = { 0 };
			memcpy(export_data.name, (char*)strFunction, strlen(strFunction));
			export_data.function_address = base;
			result.push_back(export_data);
		}
	}
	return result;
}
bool pe_action::load_pe(std::string parms_file_path)
{
	DWORD i;
	DWORD64 count = NULL;

	//1. 读入文件
	HANDLE m_file = CreateFileA(FILE, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	if (m_file == INVALID_HANDLE_VALUE)
	{
		printf("无法读入文件 %d \n", GetLastError());
		return false;
	}
	file_size = GetFileSize(m_file, NULL);
	if(m_buffer)
		VirtualFree(m_buffer, 0, MEM_RELEASE);
	if(m_image_base)
		VirtualFree((PVOID)m_image_base, 0, MEM_RELEASE);
	m_buffer = VirtualAlloc(NULL, file_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	ReadFile(m_file, m_buffer, file_size, &readed_size, NULL);
	CloseHandle(m_file);
	PIMAGE_DOS_HEADER m_dos_head = (PIMAGE_DOS_HEADER)m_buffer;
	if (m_dos_head->e_magic != IMAGE_DOS_SIGNATURE)
	{
		printf("\n 不是有效的执行文件 \n");
		VirtualFree(m_buffer, 0, MEM_RELEASE);
		return false;
	}
	m_nt_head = (PIMAGE_NT_HEADERS)((LPBYTE)m_buffer + m_dos_head->e_lfanew);
	if (m_nt_head->Signature != IMAGE_NT_SIGNATURE)
	{
		printf("\n 不是有效的PE文件 \n");
		VirtualFree(m_buffer, 0, MEM_RELEASE);
		return false;
	}

	m_image_base = (DWORD64)VirtualAlloc(NULL, m_nt_head->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	if (!WriteProcessMemory((HANDLE)-1, (PVOID)m_image_base, m_buffer, m_nt_head->OptionalHeader.SizeOfHeaders, NULL))
	{
		printf("\nError: Unable to copy headers to target process (%d)\n", GetLastError());
		return false;
	}
	relocation((PVOID)m_image_base, m_nt_head);
	map_pe_import(m_image_base);
	
	std::vector<moudle_import> import_data_dict;
	std::vector<moudle_export> export_data_dict = get_export((PVOID)m_image_base);
	push_to_virtual_helper(export_data_dict, import_data_dict, (char*)"main.exe", (uint64_t)m_image_base);
	entry_point = (DWORD64)((LPBYTE)m_nt_head->OptionalHeader.AddressOfEntryPoint);
	if (entry_point)
	{
		printf("[PE]EntryPoint: %08X \n", entry_point);
		return true;
	}
	return false;
}
void pe_action::push_to_virtual_helper(std::vector<moudle_export> params_export, std::vector<moudle_import> params_import, char* params_dll_name, uint64_t params_moudle_base)
{
	//检查dll是否已经在内存中
	struct_moudle moudle = { 0 };
	for (size_t i = 0; i < g_virtual->moudle_list.size(); i++)
	{
		if (g_virtual->moudle_list[i].base == params_moudle_base)
		{
			printf("[PE] skip %s \n", params_dll_name);
			return;
		}
	}
	//解析头
	PIMAGE_DOS_HEADER m_dos_head = (PIMAGE_DOS_HEADER)params_moudle_base;
	PIMAGE_NT_HEADERS ntheader = (PIMAGE_NT_HEADERS)((LPBYTE)params_moudle_base + m_dos_head->e_lfanew);

	DWORD SectionAlignment;

	if (ntheader->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64)
	{
		auto ntheader64 = (PIMAGE_NT_HEADERS64)ntheader;
		SectionAlignment = ntheader64->OptionalHeader.SectionAlignment;
	}
	else
	{
		SectionAlignment = ntheader->OptionalHeader.SectionAlignment;
	}
	auto SectionHeader = (PIMAGE_SECTION_HEADER)((PUCHAR)ntheader + sizeof(ntheader->Signature) + sizeof(ntheader->FileHeader) + ntheader->FileHeader.SizeOfOptionalHeader);

	for (WORD i = 0; i < ntheader->FileHeader.NumberOfSections; i++)
	{
		int prot = UC_PROT_READ;
		if (SectionHeader[i].Characteristics & IMAGE_SCN_MEM_EXECUTE)
			prot |= UC_PROT_EXEC;
		if (SectionHeader[i].Characteristics & IMAGE_SCN_MEM_WRITE)
			prot |= UC_PROT_WRITE;

		auto SectionSize = AlignSize(
			max(SectionHeader[i].Misc.VirtualSize, SectionHeader[i].SizeOfRawData),
			SectionAlignment);

		if (SectionHeader[i].Characteristics & (IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE))
		{
			moudle_section section = {0};
			memcpy(section.name, (char*)SectionHeader[i].Name, 8);
			section.name[8] = 0;
			section.base = SectionHeader[i].VirtualAddress;
			section.size = SectionSize;
			section.protect_flag = prot;
			moudle.sections.emplace_back(section);
			printf("[PE]%s Section found: %s \n", params_dll_name, (char*)SectionHeader[i].Name);
		}
	}
	memcpy(moudle.name, (char*)params_dll_name, strlen(params_dll_name));
	moudle.base = params_moudle_base;
	moudle.entry = ntheader->OptionalHeader.AddressOfEntryPoint;
	moudle.size = ntheader->OptionalHeader.SizeOfImage;
	for (size_t index = 0; index < params_export.size(); ++index)
	{
		moudle.export_function.push_back(params_export[index]);
	}
	for (size_t index = 0; index < params_import.size(); ++index)
	{
		moudle.import_function.push_back(params_import[index]);
	}
	g_virtual->moudle_list.push_back(moudle);
}

